---
phase: 02-gesture-recognition
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/game/systems/InputSystem.js
  - src/game/systems/RenderPipeline.js
  - src/game/engine/GameEngine.js
  - src/game/systems/GestureUI.js
  - src/game/systems/KeyboardFallback.js
  - src/game/systems/TrajectoryExtractor.js
autonomous: false

must_haves:
  truths:
    - "Drawing trail changes color from teal to green when a gesture is recognized"
    - "Recognized shape name and accuracy percentage appear on screen immediately after recognition"
    - "Player can continue drawing after recognition to define a trajectory direction"
    - "Pressing Q, W, or E casts the corresponding spell without drawing a gesture"
    - "Trail has visible glow effect during drawing (shadowBlur on canvas)"
  artifacts:
    - path: "src/game/systems/GestureUI.js"
      provides: "On-screen display of recognized shape name and accuracy score"
      min_lines: 40
    - path: "src/game/systems/KeyboardFallback.js"
      provides: "Keyboard shortcuts Q/W/E for emergency spell casting"
      min_lines: 30
    - path: "src/game/systems/TrajectoryExtractor.js"
      provides: "Direction extraction from post-recognition drawing continuation"
      min_lines: 30
  key_links:
    - from: "src/game/systems/InputSystem.js"
      to: "src/game/systems/GestureUI.js"
      via: "Recognition result passed to trail color and UI display"
      pattern: "recognitionResult|gestureResult"
    - from: "src/game/systems/RenderPipeline.js"
      to: "src/game/systems/GestureUI.js"
      via: "RenderPipeline calls GestureUI.render in Layer 4 (UI overlays)"
      pattern: "gestureUI.*render"
    - from: "src/game/systems/KeyboardFallback.js"
      to: "src/stores/gameStore.js"
      via: "Keyboard spell cast writes to Zustand store"
      pattern: "setLastGesture|useGameStore"
    - from: "src/game/systems/TrajectoryExtractor.js"
      to: "src/game/systems/InputSystem.js"
      via: "Extracts direction from final drawn points after recognition"
      pattern: "getPoints|currentPoints"
---

<objective>
Add visual feedback for gesture recognition (trail color change, shape name display), implement trajectory extraction from continued drawing after recognition, and add keyboard shortcuts as emergency fallback.

Purpose: This is the player-facing half of gesture recognition -- without visual feedback players don't know if their gesture was recognized, without trajectory extraction spells can't be aimed, and without keyboard fallback trackpad users are stuck. This completes Phase 2.
Output: GestureUI overlay, modified InputSystem with recognition-aware trail colors, TrajectoryExtractor utility, KeyboardFallback system.
</objective>

<execution_context>
@/Users/johnsong/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johnsong/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gesture-recognition/02-RESEARCH.md
@.planning/phases/02-gesture-recognition/02-01-SUMMARY.md
@src/game/systems/InputSystem.js
@src/game/systems/RenderPipeline.js
@src/game/engine/GameEngine.js
@src/stores/gameStore.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Visual feedback -- trail color change, gesture UI overlay, and enhanced glow</name>
  <files>
    src/game/systems/InputSystem.js
    src/game/systems/GestureUI.js
    src/game/systems/RenderPipeline.js
    src/game/engine/GameEngine.js
  </files>
  <action>
    1. Update `src/game/systems/InputSystem.js` to support recognition-aware trail rendering:
       - Add a `recognitionResult` property (null by default)
       - Add `setRecognitionResult(result)` method to set it
       - Modify `render(ctx)`:
         - Default trail: teal (`rgba(74, 143, 143, alpha)`) with light blue shadow (`rgba(126, 184, 218, 0.6)`) -- existing behavior
         - When `this.recognitionResult` is not null (gesture recognized):
           - Change trail color to green: `rgba(76, 175, 80, alpha)`
           - Change shadow color to bright green: `rgba(129, 199, 132, 0.8)`
           - Increase shadowBlur from 15 to 20 for "recognized" glow emphasis
         - Enhance base glow: increase lineWidth from 3 to 4 for better visibility
       - In `startDrawing()`: Reset `this.recognitionResult = null` (new drawing clears old recognition)

    2. Create `src/game/systems/GestureUI.js`:
       - Class with `constructor()`:
         - `this.displayResult = null` -- current result being shown
         - `this.displayTimer = 0` -- time remaining to show result (seconds)
         - `this.displayDuration = 2.0` -- show for 2 seconds
       - `showResult(result)` method:
         - Set `this.displayResult = result`
         - Set `this.displayTimer = this.displayDuration`
       - `update(dt)` method:
         - If displayTimer > 0, decrement by dt
         - If displayTimer <= 0, set displayResult to null
       - `render(ctx, canvasWidth, canvasHeight)` method:
         - If no displayResult, return
         - Calculate fade alpha: `Math.min(1, this.displayTimer / 0.5)` (fade out in last 0.5s)
         - Draw shape name centered near top-center of canvas:
           - Position: x = canvasWidth / 2, y = 80
           - Font: `bold 28px 'Cinzel Decorative', serif`
           - Color: gold `rgba(244, 232, 193, alpha)` with text shadow
           - Text: `this.displayResult.name.toUpperCase()` (e.g., "CIRCLE")
         - Draw accuracy score below shape name:
           - Position: x = canvasWidth / 2, y = 115
           - Font: `20px 'Cormorant Garamond', serif`
           - Color varies by accuracy:
             - score >= 0.90: gold `rgba(244, 232, 193, alpha)` + text "Perfect!"
             - score >= 0.80: green `rgba(129, 199, 132, alpha)` + text "Great!"
             - score >= 0.70: teal `rgba(126, 184, 218, alpha)` + text "Good"
             - score < 0.70: dim `rgba(150, 150, 150, alpha)` + text "Sloppy"
           - Also display percentage: `(score * 100).toFixed(0) + '%'` next to quality text
         - Draw damage modifier:
           - Position: x = canvasWidth / 2, y = 145
           - Font: `16px monospace`
           - Text: `${(damageModifier * 100).toFixed(0)}% damage`
           - Color: same as accuracy color but dimmer
         - Use `ctx.textAlign = 'center'` and `ctx.textBaseline = 'middle'` for centering
         - Add text shadow for readability: `ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(0, 0, 0, 0.8)'`
       - Export default class

    3. Update `src/game/systems/RenderPipeline.js`:
       - Accept `gestureUI` as a parameter in `render()`:
         `render(ctx, entityManager, inputSystem, interpolation, gestureUI)`
       - After Layer 3 (trail), in Layer 4 (UI overlays):
         - If gestureUI exists, call `gestureUI.render(ctx, canvasWidth, canvasHeight)` where canvasWidth/canvasHeight come from ctx.canvas.width/height

    4. Update `src/game/engine/GameEngine.js`:
       - Import GestureUI
       - In `init()`: Create `this.gestureUI = new GestureUI()`
       - In `handleGestureComplete(points)`:
         - After setting lastGestureResult, if result is not null:
           - Call `this.gestureUI.showResult(result)`
           - Call `this.inputSystem.setRecognitionResult(result)` to change trail color
       - In `update(dt)`: Call `this.gestureUI.update(dt)`
       - In `render()`: Pass gestureUI to renderPipeline:
         `this.renderPipeline.render(this.ctx, this.entityManager, this.inputSystem, interpolation, this.gestureUI)`
       - In `destroy()`: Clean up gestureUI reference
  </action>
  <verify>
    1. `npm run dev` starts without errors
    2. Draw a circle on canvas -- trail should turn green on release, "CIRCLE" + accuracy should appear near top-center
    3. Wait 2 seconds -- the recognition display should fade out
    4. Draw again -- trail starts teal again (resets)
    5. Draw a very short mark (< 10 points) -- no recognition display appears, trail stays teal
  </verify>
  <done>
    Drawing trail changes from teal to green when a gesture is recognized.
    Shape name, accuracy quality text (Perfect!/Great!/Good/Sloppy), and damage modifier display near top-center.
    Display fades out after 2 seconds.
    New drawings reset the trail color to teal.
  </done>
</task>

<task type="auto">
  <name>Task 2: Trajectory extraction, keyboard fallback, and Zustand integration</name>
  <files>
    src/game/systems/TrajectoryExtractor.js
    src/game/systems/KeyboardFallback.js
    src/game/engine/GameEngine.js
    src/stores/gameStore.js
  </files>
  <action>
    1. Create `src/game/systems/TrajectoryExtractor.js`:
       - Static utility class (no constructor state needed)
       - `static extract(points, numPoints = 5)` method:
         - If points.length < numPoints, return null
         - Get last N points: `const endPoints = points.slice(-numPoints)`
         - Calculate direction vector from first to last of end segment:
           - `dx = endPoints[endPoints.length - 1].x - endPoints[0].x`
           - `dy = endPoints[endPoints.length - 1].y - endPoints[0].y`
           - `magnitude = Math.sqrt(dx * dx + dy * dy)`
         - If magnitude < 10 (pixels), return null (no meaningful direction -- spell fires in default direction)
         - Return `{ angle: Math.atan2(dy, dx), magnitude, direction: { x: dx / magnitude, y: dy / magnitude }, origin: { x: endPoints[0].x, y: endPoints[0].y } }`
       - `static extractFromCenter(points)` method:
         - Calculate centroid of all points: `{ x: avg(all x), y: avg(all y) }`
         - Get last point: `points[points.length - 1]`
         - Direction = last point - centroid
         - Same magnitude check and return format as extract()
         - This gives a trajectory "from the center of the drawn shape outward"
       - Export default class

    2. Create `src/game/systems/KeyboardFallback.js`:
       - Class with `constructor()`:
         - `this.keyMap` mapping keys to spell names:
           - 'q' or 'Q': 'circle' (Quick Shot)
           - 'w' or 'W': 'triangle' (Magic Missile)
           - 'e' or 'E': 'line' (Fireball)
         - `this.onSpellCast = null` -- callback set by GameEngine
         - `this.handleKeyDown = this.handleKeyDown.bind(this)`
       - `init()`: Add keydown event listener on window
       - `handleKeyDown(e)`:
         - Look up `e.key.toLowerCase()` in keyMap
         - If found and not in a text input (check `e.target.tagName !== 'INPUT'`):
           - `e.preventDefault()`
           - If `this.onSpellCast` callback exists, call it with `{ name: spellName, score: 1.0, damageModifier: 1.0, fromKeyboard: true }`
       - `destroy()`: Remove keydown event listener
       - Export default class

    3. Update `src/game/engine/GameEngine.js`:
       - Import TrajectoryExtractor and KeyboardFallback
       - In `init()`:
         - Create `this.keyboardFallback = new KeyboardFallback()`
         - Call `this.keyboardFallback.init()`
         - Set callback: `this.keyboardFallback.onSpellCast = (result) => { this.handleKeyboardSpell(result); }`
       - Add `handleKeyboardSpell(result)` method:
         - Store: `this.lastGestureResult = result`
         - Update Zustand: `useGameStore.getState().setLastGesture(result)`
         - Show UI feedback: `this.gestureUI.showResult(result)`
         - Console.log: `console.log(\`Keyboard spell: ${result.name}\`)`
       - In `handleGestureComplete(points)`:
         - After recognition succeeds, extract trajectory:
           `const trajectory = TrajectoryExtractor.extractFromCenter(points)`
         - Add trajectory to the result object: `result.trajectory = trajectory`
         - Store it in Zustand too: include trajectory in setLastGesture call
       - In `destroy()`: Call `this.keyboardFallback.destroy()`

    4. Update `src/stores/gameStore.js`:
       - Ensure `lastGesture` can hold trajectory data (no schema change needed, it's a plain object)
       - Add `gestureHistory: []` array to track recent gestures (optional, for stats later)
       - Add `addGestureHistory: (gesture) => set(state => ({ gestureHistory: [...state.gestureHistory.slice(-9), gesture] }))` -- keep last 10
  </action>
  <verify>
    1. `npm run dev` starts without errors
    2. Draw a circle shape and release -- console shows trajectory data alongside gesture recognition
    3. Press Q key -- console logs "Keyboard spell: circle", UI shows "CIRCLE" with "Perfect!" feedback
    4. Press W key -- console logs "Keyboard spell: triangle"
    5. Press E key -- console logs "Keyboard spell: line"
    6. Press other keys (A, S, D) -- nothing happens
    7. Verify no duplicate event listeners on page navigation (go to menu and back)
  </verify>
  <done>
    Trajectory direction is extracted from the drawn gesture and included in the recognition result.
    Keyboard shortcuts Q, W, E cast circle, triangle, and line spells respectively with 100% accuracy.
    Keyboard spells show the same UI feedback as drawn gestures.
    Zustand store contains gesture history for future stats screen.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete gesture recognition system with visual feedback, trajectory extraction, and keyboard fallback:
    1. Drawing shapes triggers $1 Recognizer with visual trail color change (teal -> green on recognition)
    2. Shape name + accuracy + damage modifier displayed on screen
    3. Keyboard shortcuts Q/W/E for emergency spell casting
    4. Trajectory direction extracted from drawing for spell aiming (Phase 3)
  </what-built>
  <how-to-verify>
    1. Navigate to game screen from main menu
    2. Draw a rough circle shape on canvas:
       - Trail should be teal/cyan while drawing
       - On release, trail should turn GREEN
       - "CIRCLE" should appear near top-center with accuracy text (e.g., "Great! 82%")
       - Text should fade out after ~2 seconds
    3. Draw a triangle shape (three sides):
       - Should show "TRIANGLE" with accuracy
    4. Draw a straight line:
       - Should show "LINE" with accuracy
    5. Click quickly without dragging:
       - No recognition should trigger (< 10 points guard)
    6. Press Q key:
       - Should show "CIRCLE" with "Perfect! 100%"
    7. Press W key:
       - Should show "TRIANGLE" with "Perfect! 100%"
    8. Press E key:
       - Should show "LINE" with "Perfect! 100%"
    9. Navigate back to menu and back to game:
       - No errors, no duplicate event listeners
    10. Check browser console for gesture logs (shape name + score + trajectory)
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 2, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. Dev server runs without errors (`npm run dev`)
2. All 8 gesture templates load without errors (24 templates total)
3. Circle, triangle, and line gestures recognized at 80%+ success rate
4. Trail color changes from teal to green on recognition
5. Shape name and accuracy display appears and fades over 2 seconds
6. Keyboard Q/W/E shortcuts trigger spell cast with UI feedback
7. Trajectory direction extracted from drawn gesture (logged in console)
8. 60 FPS maintained during drawing and recognition
9. Navigation to/from game screen produces no errors or leaks
</verification>

<success_criteria>
- Player draws a circle, triangle, or line and sees the shape name displayed with accuracy feedback
- Drawing trail visibly changes color (teal -> green) when a shape is recognized
- Keyboard shortcuts Q, W, E work as emergency spell casting with "Perfect!" feedback
- Trajectory direction is extracted and available for Phase 3 spell aiming
- All visual feedback matches the dark mystical aesthetic (gold/teal/green on dark background)
- No performance degradation from recognition or visual feedback
</success_criteria>

<output>
After completion, create `.planning/phases/02-gesture-recognition/02-02-SUMMARY.md`
</output>
