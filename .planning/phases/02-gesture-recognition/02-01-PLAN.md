---
phase: 02-gesture-recognition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/game/systems/GestureRecognizer.js
  - src/game/data/gestureTemplates.js
  - src/game/engine/GameEngine.js
  - src/game/systems/InputSystem.js
  - src/stores/gameStore.js
autonomous: true

must_haves:
  truths:
    - "GestureRecognizer correctly identifies circle, triangle, and line gestures from InputSystem point arrays"
    - "Recognition triggers automatically when player stops drawing with 10+ points"
    - "Recognition result (name + score) is stored and accessible to other systems"
    - "65% match threshold provides generous recognition across mouse and trackpad input"
  artifacts:
    - path: "src/game/systems/GestureRecognizer.js"
      provides: "GestureRecognizer system with $1 Recognizer integration"
      min_lines: 60
    - path: "src/game/data/gestureTemplates.js"
      provides: "Pre-recorded gesture templates for 8 spell shapes (3 variations each)"
      min_lines: 40
  key_links:
    - from: "src/game/engine/GameEngine.js"
      to: "src/game/systems/GestureRecognizer.js"
      via: "GameEngine creates GestureRecognizer, passes InputSystem points on stopDrawing"
      pattern: "GestureRecognizer"
    - from: "src/game/systems/GestureRecognizer.js"
      to: "src/game/data/gestureTemplates.js"
      via: "import and load templates into $1 recognizer"
      pattern: "gestureTemplates|GESTURE_TEMPLATES"
    - from: "src/game/systems/GestureRecognizer.js"
      to: "@2players/dollar1-unistroke-recognizer"
      via: "npm import"
      pattern: "import.*dollar1"
---

<objective>
Integrate the $1 Unistroke Recognizer for shape detection, create gesture templates for 8 spell shapes, and wire recognition into the game loop so drawing a shape and releasing produces a recognition result.

Purpose: This is the core gesture recognition engine -- without it, players cannot cast spells by drawing. Everything in Phase 2-7 depends on shapes being reliably detected.
Output: GestureRecognizer system, gesture template data file, recognition wired into GameEngine update/stopDrawing flow, recognition result stored in Zustand.
</objective>

<execution_context>
@/Users/johnsong/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johnsong/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gesture-recognition/02-RESEARCH.md
@src/game/systems/InputSystem.js
@src/game/engine/GameEngine.js
@src/stores/gameStore.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GestureRecognizer system and gesture templates</name>
  <files>
    src/game/systems/GestureRecognizer.js
    src/game/data/gestureTemplates.js
    package.json
  </files>
  <action>
    1. Install the $1 Recognizer library:
       ```bash
       npm install @2players/dollar1-unistroke-recognizer
       ```

    2. Create `src/game/data/gestureTemplates.js` with template data for 8 spell shapes:
       - circle (Quick Shot spell)
       - triangle (Magic Missile spell)
       - line/swipe (Fireball spell)
       - zigzag (Lightning spell -- reserved for future)
       - spiral (Life Drain spell -- reserved for future)
       - circle-dot (Shield spell -- reserved for future)
       - horizontal-swipe (Dash spell -- reserved for future)
       - star (Meteor Storm ultimate -- reserved for future)

       For each shape, provide 3 template variations as arrays of {x, y} points. Generate these programmatically using mathematical formulas:
       - Circle: Points along a circle arc (cos/sin at regular intervals)
       - Triangle: Three sides drawn as connected line segments
       - Line/swipe: Diagonal or horizontal line points
       - Zigzag: Alternating up-down segments
       - Spiral: Shrinking circle with decreasing radius
       - Star: 5-pointed star drawn as connected line segments
       Add slight random jitter (+/- 2-5px) to variation 2 and 3 to simulate human drawing imprecision.

       Export as array of `{ name: string, variations: Point[][] }` where Point is `{x: number, y: number}`.

    3. Create `src/game/systems/GestureRecognizer.js`:
       - Import GestureRecognizer from '@2players/dollar1-unistroke-recognizer'
       - Constructor: create recognizer instance with `{ defaultStrokes: false }` (no built-in defaults, only our templates)
       - `loadTemplates()`: Import GESTURE_TEMPLATES, iterate over each shape's variations, add each as `${name}-${variationIndex}` to the recognizer via `this.recognizer.add(templateName, points)`
       - `recognize(points)`: Takes array of {x, y} points from InputSystem
         - Return null if points.length < 10 (too few points to recognize)
         - Convert points to [{x, y}] format (strip timestamp/alpha)
         - Call `this.recognizer.recognize(stroke, true)` (useProtractor=true for speed)
         - Extract base gesture name by splitting result.name on '-' and taking first part
         - If result.score >= this.recognitionThreshold (0.65), return `{ name, score, damageModifier }` where damageModifier = calculateDamageModifier(score)
         - Otherwise return null
       - `calculateDamageModifier(score)`: Linear map from [0.60, 1.00] -> [0.5, 1.0]
         - Formula: `0.5 + ((clampedScore - 0.60) / (1.00 - 0.60)) * 0.5`
       - `getLastResult()`: Returns the most recent recognition result (or null)
       - `clearResult()`: Resets lastResult to null
       - Export default class

       IMPORTANT: The recognizer library uses `new GestureRecognizer()` as the default import. If the import fails or the API differs, fall back to implementing the $1 algorithm directly from the research paper (it's ~100 lines). Check the actual npm package API by reading node_modules after install.
  </action>
  <verify>
    1. `npm ls @2players/dollar1-unistroke-recognizer` shows the package installed
    2. `node -e "import('./src/game/data/gestureTemplates.js').then(m => console.log(Object.keys(m.default || m.GESTURE_TEMPLATES || m).length + ' shapes'))"` -- may need to check export format
    3. The dev server (`npm run dev`) starts without import errors
  </verify>
  <done>
    GestureRecognizer class exists with loadTemplates(), recognize(), calculateDamageModifier() methods.
    gestureTemplates.js exports template data for 8 shapes with 3 variations each (24 total templates).
    npm package installed and importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire GestureRecognizer into GameEngine and InputSystem</name>
  <files>
    src/game/engine/GameEngine.js
    src/game/systems/InputSystem.js
    src/stores/gameStore.js
  </files>
  <action>
    1. Update `src/stores/gameStore.js`:
       - Add gesture state fields:
         - `lastGesture: null` -- most recent recognition result `{ name, score, damageModifier }` or null
         - `isDrawing: false` -- whether player is currently drawing
       - Add actions:
         - `setLastGesture: (gesture) => set({ lastGesture: gesture })`
         - `setIsDrawing: (drawing) => set({ isDrawing: drawing })`
         - `clearGesture: () => set({ lastGesture: null })`

    2. Update `src/game/systems/InputSystem.js`:
       - Add an `onStopDrawing` callback property (set to null by default, GameEngine will assign it)
       - In `stopDrawing()`: After setting `this.isDrawing = false`, if `this.onStopDrawing` is a function and `this.currentPoints.length >= 10`, call `this.onStopDrawing(this.getPoints())`
       - Do NOT clear currentPoints in stopDrawing -- they need to persist until next startDrawing (for trajectory extraction in Plan 02)

    3. Update `src/game/engine/GameEngine.js`:
       - Import GestureRecognizer from '../systems/GestureRecognizer.js'
       - In `init()`:
         - Create `this.gestureRecognizer = new GestureRecognizer()` after InputSystem creation
         - Set `this.inputSystem.onStopDrawing = (points) => { this.handleGestureComplete(points); }`
       - Add `handleGestureComplete(points)` method:
         - Call `const result = this.gestureRecognizer.recognize(points)`
         - If result is not null:
           - Store: `this.lastGestureResult = result`
           - Update Zustand: `useGameStore.getState().setLastGesture(result)`
           - Console.log for debugging: `console.log(\`Gesture: ${result.name} (${(result.score * 100).toFixed(0)}%)\`)`
         - If result is null:
           - `this.lastGestureResult = null`
           - `useGameStore.getState().clearGesture()`
       - In `destroy()`: Clean up gestureRecognizer reference
  </action>
  <verify>
    1. `npm run dev` starts without errors
    2. Open browser console, draw a circle-like shape on canvas, release mouse -- console should log "Gesture: circle (XX%)" or similar
    3. Draw a straight line, release -- should log "Gesture: line (XX%)" or similar
    4. Quick click (< 10 points) -- should NOT trigger recognition (no console log)
  </verify>
  <done>
    Drawing a shape on the canvas and releasing the mouse triggers gesture recognition.
    Console logs the recognized shape name and accuracy score.
    Recognition result is stored in both GameEngine.lastGestureResult and Zustand store.
    Short clicks (< 10 points) do not trigger false recognitions.
  </done>
</task>

</tasks>

<verification>
1. Start dev server with `npm run dev`
2. Navigate to game screen
3. Draw a rough circle shape on canvas -- console should log recognition with shape name "circle" and score > 0.65
4. Draw a rough triangle shape -- console should log "triangle" with score > 0.65
5. Draw a straight line -- console should log "line" with score > 0.65
6. Quick click without dragging -- no recognition should trigger
7. Verify no console errors or warnings from imports
</verification>

<success_criteria>
- $1 Recognizer npm package is installed and functional
- 8 gesture shapes are defined with 3 variations each (24 templates loaded)
- Drawing shapes on canvas triggers recognition on mouse-up
- Circle, triangle, and line are recognized at 65%+ threshold
- Recognition results include name, score, and damageModifier
- Zustand store reflects gesture recognition state
- No performance degradation (60 FPS maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/02-gesture-recognition/02-01-SUMMARY.md`
</output>
