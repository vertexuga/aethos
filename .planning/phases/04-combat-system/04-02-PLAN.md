---
phase: 04-combat-system
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/game/systems/WaveSpawner.js
  - src/game/data/waveConfig.js
  - src/game/entities/enemies/DeathParticle.js
  - src/game/systems/DeathParticlePool.js
  - src/game/engine/GameEngine.js
  - src/game/systems/RenderPipeline.js
autonomous: false

must_haves:
  truths:
    - "Waves of enemies spawn at screen edges with increasing difficulty"
    - "Dead enemies burst into colored particles that fade out"
    - "Wave counter or indicator is visible on screen"
    - "After clearing a wave, a new harder wave spawns after a brief delay"
    - "The full combat loop is playable: draw spell, cast, kill enemies, survive waves"
  artifacts:
    - path: "src/game/systems/WaveSpawner.js"
      provides: "Configurable wave spawning with composition arrays, spawn timing, edge spawning"
      exports: ["default (WaveSpawner)"]
    - path: "src/game/data/waveConfig.js"
      provides: "Wave composition definitions with increasing difficulty"
      exports: ["WAVE_CONFIG"]
    - path: "src/game/entities/enemies/DeathParticle.js"
      provides: "Fade-out particle entity for enemy death effects"
      exports: ["default (DeathParticle)"]
    - path: "src/game/systems/DeathParticlePool.js"
      provides: "Object pool for death particles to prevent GC pauses"
      exports: ["default (DeathParticlePool)"]
  key_links:
    - from: "src/game/systems/WaveSpawner.js"
      to: "src/game/systems/EnemyPool.js"
      via: "WaveSpawner calls enemyPool.spawn() to create enemies"
      pattern: "enemyPool.*spawn|this\\.pools.*spawn"
    - from: "src/game/engine/GameEngine.js"
      to: "src/game/systems/WaveSpawner.js"
      via: "GameEngine update loop calls waveSpawner.update(dt)"
      pattern: "waveSpawner\\.update"
    - from: "SlimeEnemy.die()"
      to: "DeathParticlePool"
      via: "Death handler spawns 8 radial particles at enemy position"
      pattern: "spawnDeathParticles|deathParticle.*spawn"
    - from: "src/game/systems/RenderPipeline.js"
      to: "Wave indicator HUD"
      via: "HUD layer renders wave number"
      pattern: "wave.*text|Wave.*render"
---

<objective>
Add wave-based enemy spawning with configurable compositions, enemy death particle effects, wave progression HUD, and final GameEngine integration to make the core combat loop (draw, cast, kill, survive) fully playable end-to-end.

Purpose: This plan completes the Phase 4 combat system by adding the game's pacing (waves), visual satisfaction (death effects), and progression (increasing difficulty). Without waves, combat is a one-off encounter. With waves, it becomes a game.

Output: Enemies spawn in waves from screen edges, dying enemies burst into particles, wave counter on HUD, increasing difficulty across waves, fully playable combat loop.
</objective>

<execution_context>
@/Users/johnsong/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johnsong/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-combat-system/04-RESEARCH.md
@.planning/phases/04-combat-system/04-01-SUMMARY.md

Key existing files to reference:
@src/game/engine/GameEngine.js -- Updated in 04-01 with Player, SlimePool, CollisionSystem
@src/game/systems/EnemyPool.js -- Created in 04-01, spawn/release/update pattern
@src/game/entities/enemies/SlimeEnemy.js -- Created in 04-01, has die() with justDied flag
@src/game/data/enemyConfig.js -- Created in 04-01, ENEMY_CONFIG with slime stats
@src/game/systems/RenderPipeline.js -- Updated in 04-01 with HP bar HUD
@src/game/systems/ProjectilePool.js -- Reference pattern for DeathParticlePool
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create death particles, wave spawner, wave config, and wire into GameEngine</name>
  <files>
    src/game/entities/enemies/DeathParticle.js
    src/game/systems/DeathParticlePool.js
    src/game/systems/WaveSpawner.js
    src/game/data/waveConfig.js
    src/game/engine/GameEngine.js
    src/game/systems/RenderPipeline.js
  </files>
  <action>
**Create `src/game/entities/enemies/DeathParticle.js`:**
Simple entity for enemy death burst effect:
- Extend Entity base class
- Constructor: `{ x, y, vx, vy, color, lifetime = 500 }` with `size: 3`, `type: 'particle-death'`
- Properties: `lifetime` (ms), `age = 0`, `initialSize = 3`
- `update(dt)`: Call `super.update(dt)` for velocity movement. Increment age by `dt * 1000`. Apply friction/deceleration: `vx *= 0.97; vy *= 0.97`. If age >= lifetime, call `destroy()`.
- `render(ctx)`: Calculate alpha as `1 - (age / lifetime)` for fade-out. Calculate size as `initialSize * (1 - age / lifetime * 0.5)` for slight shrink. Draw circle with globalAlpha = alpha. Use the enemy's color.
- `reset({ x, y, vx, vy, color, lifetime })`: Reset all properties for pool reuse. Set active=true, age=0.

**Create `src/game/systems/DeathParticlePool.js`:**
Follow ProjectilePool pattern but for DeathParticle:
- Constructor: `(poolSize = 80)`. Pre-allocate poolSize DeathParticle instances. 80 because: 20 enemies max * 8 particles each = 160, but particles die in 500ms so pool of 80 recycles fast enough.
- `spawn({ x, y, vx, vy, color, lifetime })`: Same pool pop/reset pattern.
- `release(particle)`: Same inactive/splice/push pattern.
- `update(dt)`: Iterate backwards, release inactive, update active.
- `spawnBurst(x, y, color, count = 8)`: Convenience method that spawns `count` particles in radial pattern. For each particle: `angle = (Math.PI * 2 * i) / count`, `speed = 120 + Math.random() * 60` (slight randomness), `vx = cos(angle) * speed`, `vy = sin(angle) * speed`. Adds each spawned particle to entityManager (passed in constructor or as param).
- Store entityManager reference: `constructor(entityManager, poolSize = 80)` so spawnBurst can add particles to the entity list.

**Create `src/game/data/waveConfig.js`:**
Export `WAVE_CONFIG` array with 5+ wave definitions for demo:
```javascript
export const WAVE_CONFIG = [
  {
    wave: 1,
    composition: [{ type: 'slime', count: 3 }],
    spawnInterval: 1200,  // ms between each spawn
    delayBefore: 2000,    // ms before wave starts
  },
  {
    wave: 2,
    composition: [{ type: 'slime', count: 5 }],
    spawnInterval: 1000,
    delayBefore: 3000,
  },
  {
    wave: 3,
    composition: [{ type: 'slime', count: 7 }],
    spawnInterval: 800,
    delayBefore: 3000,
  },
  {
    wave: 4,
    composition: [{ type: 'slime', count: 10 }],
    spawnInterval: 700,
    delayBefore: 3000,
  },
  {
    wave: 5,
    composition: [{ type: 'slime', count: 12 }],
    spawnInterval: 600,
    delayBefore: 3000,
  },
];
// After wave 5, generate procedural waves: slime count = 12 + (wave - 5) * 2, interval decreases
```
Also export a helper: `export function getWaveConfig(waveNumber)` that returns the config for wave N, generating procedural configs for waves beyond the defined array.

**Create `src/game/systems/WaveSpawner.js`:**
Wave-based spawning system:
- Constructor: `(enemyPools, entityManager, canvasWidth, canvasHeight)`. `enemyPools` is `{ slime: EnemyPool }` object.
- Properties: `currentWave = 0`, `waveState = 'waiting'` (waiting | spawning | active | cleared), `spawnQueue = []`, `spawnTimer = 0`, `delayTimer = 0`, `totalEnemiesInWave = 0`, `enemiesKilledInWave = 0`
- `startNextWave()`: Increment currentWave. Get config from WAVE_CONFIG (or generate procedural). Build spawn queue from composition (shuffle for variety). Set waveState to 'waiting', delayTimer to config.delayBefore.
- `update(dt)`:
  - If `waiting`: countdown delayTimer. When done, switch to `spawning`.
  - If `spawning`: countdown spawnTimer. When reached interval, pop from queue, call `spawnEnemy(type)`. When queue empty, switch to `active`.
  - If `active`: Check if all enemies from this wave are dead (count active enemies of wave). When all dead, switch to `cleared`.
  - If `cleared`: Auto-start next wave after a brief 1.5s delay.
- `spawnEnemy(type)`: Calculate random screen edge position (with 30px offset outside canvas). Look up stats from ENEMY_CONFIG[type]. Call `this.enemyPools[type].spawn(params)`. Add spawned enemy to entityManager.
- `getActiveEnemyCount()`: Count active enemies across all pools.
- `setCanvasSize(width, height)`: Update canvas dimensions for spawn edge calculation.
- `getCurrentWave()`: Return currentWave number.
- `getWaveState()`: Return waveState string.

**Modify `src/game/engine/GameEngine.js`:**
Integrate wave spawner and death particles. Changes:

1. Add imports:
```javascript
import WaveSpawner from '../systems/WaveSpawner.js';
import DeathParticlePool from '../systems/DeathParticlePool.js';
import { WAVE_CONFIG } from '../data/waveConfig.js';
```

2. Add new properties in constructor:
```javascript
this.waveSpawner = null;
this.deathParticlePool = null;
```

3. In `init()`, after creating slimePool and collisionSystem:
- Create DeathParticlePool: `this.deathParticlePool = new DeathParticlePool(this.entityManager, 80);`
- Create WaveSpawner: `this.waveSpawner = new WaveSpawner({ slime: this.slimePool }, this.entityManager, this.width, this.height);`
- Remove the test slime spawning from 04-01 (replace with wave spawner).
- Start first wave: `this.waveSpawner.startNextWave();`

4. In `update(dt)`, add these steps in order:
- After updating enemy pool: `this.waveSpawner.update(dt);`
- After updating death particle pool: `this.deathParticlePool.update(dt);`
- After collision system runs: Check slimePool active enemies for `justDied === true`. For each dead enemy: call `this.deathParticlePool.spawnBurst(enemy.x, enemy.y, enemy.color)`, then reset `justDied = false`. This connects enemy death to particle effects.

5. In `render()`: Pass waveSpawner to RenderPipeline for wave HUD.

6. In `resize()`: Update waveSpawner canvas size.

7. In `destroy()`: Null out waveSpawner and deathParticlePool.

**Modify `src/game/systems/RenderPipeline.js`:**
Add wave indicator to HUD:

1. Update `render()` signature to also accept waveSpawner: `render(ctx, entityManager, inputSystem, interpolation, gestureUI, player, waveSpawner)`
2. Update `renderHUD()` to also accept waveSpawner.
3. In renderHUD, add wave display:
- Position: top-right corner, `x = canvasWidth - 120, y = 20`
- Text: "Wave {N}" in Cinzel Decorative or monospace font, size 16px
- Color: teal `rgba(126, 184, 218, 0.8)`, with subtle glow (shadowBlur 5, shadowColor teal)
- During 'waiting' state: show "Wave {N} incoming..." with pulsing alpha
- During 'cleared' state: briefly flash "Wave Cleared!" in gold (#d4a574) for 1-2 seconds

4. Also add an enemy count indicator near the wave text: "Enemies: {N}" showing active enemy count.
  </action>
  <verify>
Check all new files exist:
```bash
ls src/game/entities/enemies/DeathParticle.js src/game/systems/DeathParticlePool.js src/game/systems/WaveSpawner.js src/game/data/waveConfig.js
```
Check WaveSpawner has key methods: `grep -E "startNextWave|spawnEnemy|update" src/game/systems/WaveSpawner.js`
Check GameEngine integrates wave spawner: `grep "waveSpawner" src/game/engine/GameEngine.js`
Check RenderPipeline has wave HUD: `grep -i "wave" src/game/systems/RenderPipeline.js`
Run `npm run dev` -- verify game loads, waves start spawning, enemies die with particles.
  </verify>
  <done>
WaveSpawner: Spawns enemies in configurable waves from screen edges with waiting/spawning/active/cleared states. 5 pre-defined waves + procedural generation. Auto-advances between waves.
DeathParticle + DeathParticlePool: 8-particle radial burst on enemy death, 500ms fade-out, 80-particle pool. Colors match dying enemy.
waveConfig.js: 5 waves from 3 slimes (wave 1) to 12 slimes (wave 5) with decreasing spawn intervals. Procedural generation beyond wave 5.
GameEngine: WaveSpawner and DeathParticlePool integrated into update loop. Enemy death triggers particle burst. Test slimes replaced with wave system.
RenderPipeline: Wave number and enemy count displayed in HUD top-right. Wave state indicators (incoming, cleared).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify complete combat loop</name>
  <what-built>
Complete Phase 4 combat system: Player with WASD movement, Slime enemies chasing with health bars, spell projectiles dealing damage with white flash, player contact damage with i-frames, wave spawning with increasing difficulty, death particle effects, HP bar and wave counter HUD.
  </what-built>
  <how-to-verify>
1. Run `npm run dev` and navigate to the game screen
2. Verify PLAYER: You control a circle with WASD keys, it moves smoothly and stays within screen bounds
3. Verify ENEMIES: Slime enemies spawn from screen edges and chase toward you
4. Verify COMBAT: Draw a circle (or press Q) to fire a spell -- it should hit and damage a slime
5. Verify HIT FEEDBACK: When a spell hits, the slime flashes white briefly and its health bar decreases
6. Verify DEATH: When a slime's HP reaches 0, it bursts into colored particles that fade out
7. Verify CONTACT DAMAGE: Let a slime reach you -- your HP bar should decrease, and your character should flicker (i-frames)
8. Verify WAVES: After killing all slimes in a wave, "Wave Cleared!" appears, then a new wave with more enemies spawns
9. Verify HUD: HP bar visible top-left, Wave number and enemy count visible top-right
10. Verify SPELLS STILL WORK: Drawing triangle and zigzag gestures still cast Magic Missile and Fireball correctly
11. Verify PERFORMANCE: Game maintains smooth 60 FPS with enemies + projectiles + particles active
  </how-to-verify>
  <resume-signal>Type "approved" if the combat loop feels good, or describe any issues with movement, collision, damage feedback, or wave spawning</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete and checkpoint approved:
1. Full combat loop is playable: draw gesture -> spell fires -> hits enemy -> enemy takes damage -> enemy dies with particles -> wave clears -> new wave spawns
2. Player survives multiple waves using spell casting and WASD dodging
3. All 3 spell types (QuickShot, MagicMissile, Fireball) deal damage to enemies
4. Player HP decreases from contact damage with visible i-frames
5. Wave difficulty increases (more enemies per wave)
6. HUD shows both HP bar and wave information
7. Performance remains at 60 FPS throughout
</verification>

<success_criteria>
- Waves of Slime enemies spawn from screen edges with increasing count per wave (3 -> 5 -> 7 -> 10 -> 12+)
- Dead enemies produce 8-particle radial burst that fades over 500ms
- Wave counter displays current wave number on HUD
- Cleared waves auto-advance to next wave after brief delay
- The complete gameplay loop works: draw, cast, kill, survive, next wave
- All existing spell functionality (3 spell types, gesture + keyboard) unaffected
- 60 FPS maintained with 10+ enemies, particles, and projectiles active simultaneously
</success_criteria>

<output>
After completion, create `.planning/phases/04-combat-system/04-02-SUMMARY.md`
</output>
