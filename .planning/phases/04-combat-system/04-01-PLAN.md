---
phase: 04-combat-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/entities/player/Player.js
  - src/game/entities/enemies/SlimeEnemy.js
  - src/game/data/enemyConfig.js
  - src/game/systems/EnemyPool.js
  - src/game/systems/CollisionSystem.js
  - src/game/engine/GameEngine.js
  - src/game/systems/RenderPipeline.js
autonomous: true

must_haves:
  truths:
    - "Player entity exists on screen and moves with WASD keyboard input"
    - "Slime enemies chase the player with smooth movement"
    - "Spell projectiles destroy enemies on contact and deal damage"
    - "Enemies display health bars above them that decrease when hit"
    - "Enemies flash white briefly when taking damage"
    - "Player takes damage from enemy contact with invincibility frames preventing rapid hits"
    - "Player HP bar is visible on the HUD"
  artifacts:
    - path: "src/game/entities/player/Player.js"
      provides: "Player entity with WASD movement, HP system, i-frames, contact damage"
      exports: ["default (Player)"]
    - path: "src/game/entities/enemies/SlimeEnemy.js"
      provides: "Slime enemy with chase AI, health bar, white flash, reset protocol"
      exports: ["default (SlimeEnemy)"]
    - path: "src/game/data/enemyConfig.js"
      provides: "Enemy balance values (HP, speed, damage, color, size)"
      exports: ["ENEMY_CONFIG"]
    - path: "src/game/systems/EnemyPool.js"
      provides: "Object pool for enemy entities matching ProjectilePool pattern"
      exports: ["default (EnemyPool)"]
    - path: "src/game/systems/CollisionSystem.js"
      provides: "Circle-circle collision detection with detection-then-response pattern"
      exports: ["default (CollisionSystem)"]
  key_links:
    - from: "src/game/systems/CollisionSystem.js"
      to: "EntityManager"
      via: "getByType() to find projectiles and enemies"
      pattern: "getByType.*projectile|getByType.*enemy|getByType.*player"
    - from: "src/game/entities/enemies/SlimeEnemy.js"
      to: "src/game/entities/player/Player.js"
      via: "Chase AI calculates direction vector toward player each frame"
      pattern: "player\\.x.*this\\.x|dx.*dy.*distance"
    - from: "src/game/engine/GameEngine.js"
      to: "src/game/systems/CollisionSystem.js"
      via: "CollisionSystem.update(dt) called in GameEngine update loop"
      pattern: "collisionSystem\\.update"
    - from: "src/game/systems/RenderPipeline.js"
      to: "Player HP bar"
      via: "HUD layer renders HP bar after entities and trail"
      pattern: "renderHUD|hpBar|hp.*bar"
---

<objective>
Create the core combat entities and collision system: a player entity with WASD movement and HP, Slime enemies with chase AI and health bars, circle-circle collision detection linking projectiles to enemies and enemies to player, damage application with visual feedback (white flash, health bars), and an HP bar HUD.

Purpose: This plan creates the foundational combat infrastructure that makes spells meaningful -- projectiles now hit things, enemies now threaten the player, and the draw-cast-kill loop becomes real gameplay.

Output: Player moves with WASD, Slime enemies chase with health bars, projectiles deal damage with white flash feedback, player takes contact damage with i-frames, HP bar on HUD.
</objective>

<execution_context>
@/Users/johnsong/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johnsong/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-combat-system/04-RESEARCH.md

Key existing files to reference:
@src/game/entities/Entity.js -- Base entity class (x, y, vx, vy, size, type, color, active, update(dt), render(ctx), destroy())
@src/game/entities/EntityManager.js -- add/remove/update/render/getByType/getAll, deferred deletion
@src/game/systems/ProjectilePool.js -- Pool pattern to replicate for EnemyPool (pool[], active[], spawn, release, update)
@src/game/data/spellConfig.js -- SPELL_CONFIG with baseDamage values (QuickShot=10, MagicMissile=8, Fireball=15)
@src/game/engine/GameEngine.js -- Main orchestrator, update/render loop, systems array
@src/game/systems/RenderPipeline.js -- Layer order: entities -> trail -> UI
@src/game/entities/projectiles/QuickShotEntity.js -- getDamage() pattern: baseDamage * damageModifier
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Player entity, Slime enemy, enemy config, and EnemyPool</name>
  <files>
    src/game/entities/player/Player.js
    src/game/entities/enemies/SlimeEnemy.js
    src/game/data/enemyConfig.js
    src/game/systems/EnemyPool.js
  </files>
  <action>
**Create `src/game/data/enemyConfig.js`:**
Export `ENEMY_CONFIG` object with research-based balance values:
```javascript
export const ENEMY_CONFIG = {
  slime: {
    name: 'Slime',
    hp: 25,
    speed: 100,         // px/sec (40% of player speed 250)
    contactDamage: 10,
    size: 14,           // radius in px
    color: '#4caf50',   // Green
    xpReward: 10
  }
};
```

**Create `src/game/entities/player/Player.js`:**
Extend Entity base class. Key requirements:
- Constructor: `{ x, y }` with `size: 16`, `type: 'player'`, `color: '#7eb8da'` (matches existing teal palette)
- Properties: `hp = 100`, `maxHp = 100`, `speed = 250` (px/sec), `invincible = false`, `invincibilityDuration = 1000` (ms), `invincibilityTimer = 0`, `hitFlashTimer = 0`
- `moveDirection = { x: 0, y: 0 }` for WASD input (set externally by GameEngine's keyboard handler)
- `update(dt)`: Apply movement from moveDirection (normalize diagonal to prevent 1.41x speed), countdown invincibilityTimer and hitFlashTimer. Do NOT call `super.update(dt)` for movement -- use moveDirection instead of vx/vy so the player doesn't drift. Keep the player clamped within canvas bounds (need canvasWidth/canvasHeight passed to constructor or set via method).
- `takeDamage(amount)`: If invincible, return. Subtract from hp, clamp to 0. Set invincible=true, invincibilityTimer=invincibilityDuration, hitFlashTimer=200.
- `render(ctx)`: Draw circle. If hitFlashTimer > 0, use fillStyle '#ffffff' with shadowBlur 15 and shadowColor '#ffffff'. If invincible, flicker with globalAlpha toggling every 100ms (`Math.floor(invincibilityTimer / 100) % 2 === 0 ? 0.4 : 1.0`). Draw a small directional indicator (line from center in moveDirection) so player has orientation.
- `setCanvasSize(width, height)`: Store canvas bounds for clamping.

**Create `src/game/entities/enemies/SlimeEnemy.js`:**
Extend Entity base class. Key requirements:
- Constructor: `{ x, y, speed, hp }` with `size: ENEMY_CONFIG.slime.size`, `type: 'enemy-slime'`, `color: ENEMY_CONFIG.slime.color`
- Properties: `maxHp`, `contactDamage = ENEMY_CONFIG.slime.contactDamage`, `hitFlashTimer = 0`, `maxSpeed` (from speed param)
- `update(dt, player)`: Calculate normalized direction vector from this to player, set vx/vy = direction * maxSpeed. Call `super.update(dt)` to apply velocity. Countdown hitFlashTimer.
- `takeDamage(amount)`: Subtract from hp, set hitFlashTimer = 150. If hp <= 0, call `this.die()`.
- `die()`: Set `this.active = false`. Store `this.justDied = true` so the pool/spawner can trigger death effects.
- `render(ctx)`: Draw circle body. If hitFlashTimer > 0, fillStyle = '#ffffff' with white shadow glow. Call `renderHealthBar(ctx)` after body.
- `renderHealthBar(ctx)`: Draw bar above enemy. Width = `size * 2.5`, height = 3px, positioned at `y - size - 8`. Background dark bar, foreground colored by HP percent (green > 50%, yellow > 25%, red otherwise). Only show if hp < maxHp (don't clutter full-health enemies).
- `reset({ x, y, speed, hp })`: Reset all properties for object pool reuse. Set active=true, hitFlashTimer=0, justDied=false, recalculate maxHp, maxSpeed.

**Create `src/game/systems/EnemyPool.js`:**
Follow the exact same pattern as ProjectilePool.js:
- Constructor: `(EnemyClass, poolSize = 20)`. Pre-allocate poolSize instances with `{ x: 0, y: 0, speed: 0, hp: 0 }`, set `active = false`.
- `spawn({ x, y, speed, hp })`: Pop from pool, call `reset(params)`, push to active. Fallback: create new if pool exhausted (with console.warn).
- `release(enemy)`: Set inactive, remove from active, push back to pool if under capacity.
- `update(dt, player)`: Iterate backwards. If enemy `!active`, release it. Otherwise call `enemy.update(dt, player)` passing the player reference for AI.
- `getActive()`: Return active array.
- Store `this.poolSize` for capacity check in release (the existing ProjectilePool pattern).
  </action>
  <verify>
Check all 4 files exist and export correctly:
```bash
ls src/game/entities/player/Player.js src/game/entities/enemies/SlimeEnemy.js src/game/data/enemyConfig.js src/game/systems/EnemyPool.js
```
Check Player extends Entity: `grep "extends Entity" src/game/entities/player/Player.js`
Check SlimeEnemy extends Entity: `grep "extends Entity" src/game/entities/enemies/SlimeEnemy.js`
Check EnemyPool has spawn/release/update: `grep -E "spawn|release|update" src/game/systems/EnemyPool.js`
Check ENEMY_CONFIG exports: `grep "ENEMY_CONFIG" src/game/data/enemyConfig.js`
  </verify>
  <done>
Player.js: extends Entity, has WASD movement via moveDirection, HP system (100/100), takeDamage with i-frames (1000ms), white flash (200ms), flicker during invincibility, canvas clamping.
SlimeEnemy.js: extends Entity, chase AI toward player via normalized direction vector, health bar rendering (green/yellow/red), white flash on damage (150ms), die() method with justDied flag, reset() for pool reuse.
enemyConfig.js: Exports ENEMY_CONFIG with slime stats (hp:25, speed:100, contactDamage:10, size:14, color:#4caf50).
EnemyPool.js: Matches ProjectilePool pattern with spawn/release/update, pre-allocates 20 slimes, passes player to enemy.update() for AI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CollisionSystem, wire into GameEngine, add HP bar HUD</name>
  <files>
    src/game/systems/CollisionSystem.js
    src/game/engine/GameEngine.js
    src/game/systems/RenderPipeline.js
  </files>
  <action>
**Create `src/game/systems/CollisionSystem.js`:**
Detection-then-response pattern (per research). Key requirements:
- Constructor: `(entityManager)`. Store reference.
- Helper function (module-level or static): `checkCircleCollision(a, b)` using squared distance: `dx*dx + dy*dy < (a.size + b.size)^2`. Avoids Math.sqrt.
- `update(dt)`:
  - Phase 1 (Detection): Collect all collision pairs into `this.collisions = []`.
    - Get all active entities. Filter projectiles by type starting with 'projectile-' (but NOT 'particle-' types like FireballExplosion). Filter enemies by type starting with 'enemy-'.
    - Get player by type 'player' (first result).
    - Loop: for each projectile, for each enemy, if `checkCircleCollision(proj, enemy)` -> push `{ type: 'projectile-enemy', projectile: proj, enemy }`.
    - Loop: for each enemy, if player exists and `checkCircleCollision(enemy, player)` -> push `{ type: 'enemy-player', enemy, player }`.
  - Phase 2 (Response): Iterate collected collisions.
    - `projectile-enemy`: Call `enemy.takeDamage(projectile.getDamage())`. Call `projectile.destroy()`.
    - `enemy-player`: Call `player.takeDamage(enemy.contactDamage)`. (Player's takeDamage handles i-frames.)
  - IMPORTANT: Filter projectile types carefully. The `FireballExplosion` has type 'vfx-explosion', not 'projectile-', so it won't accidentally match. But verify by checking existing entity types.
  - IMPORTANT: Only check enemies that are active. Only check projectiles that are active. Skip if player is null (not yet spawned).

**Modify `src/game/engine/GameEngine.js`:**
Add combat system integration. Changes needed:

1. Add imports at top:
```javascript
import Player from '../entities/player/Player.js';
import SlimeEnemy from '../entities/enemies/SlimeEnemy.js';
import EnemyPool from '../systems/EnemyPool.js';
import CollisionSystem from '../systems/CollisionSystem.js';
import { ENEMY_CONFIG } from '../data/enemyConfig.js';
```

2. Add new properties in constructor:
```javascript
this.player = null;
this.slimePool = null;
this.collisionSystem = null;
```

3. In `init()`, after creating entityManager and before creating gameLoop:
- Create Player at canvas center: `this.player = new Player({ x: this.width / 2, y: this.height / 2 }); this.player.setCanvasSize(this.width, this.height); this.entityManager.add(this.player);`
- Create SlimePool: `this.slimePool = new EnemyPool(SlimeEnemy, 20);`
- Create CollisionSystem: `this.collisionSystem = new CollisionSystem(this.entityManager);`
- Add WASD keyboard handler: Listen for keydown/keyup on 'w','a','s','d' (and 'W','A','S','D'). Track held keys in a Set. Each frame, compute moveDirection from held keys and set `this.player.moveDirection`. Add the event listeners and store references for cleanup. NOTE: This must NOT conflict with existing KeyboardFallback (Q/W/E). The 'w' key overlaps -- handle this carefully. Best approach: In the WASD handler, use lowercase detection. The existing KeyboardFallback uses uppercase 'Q','W','E' in its keydown handler. Check KeyboardFallback.js to see how it handles keys. If conflict, adjust so W key serves double duty (movement) or use different scheme. WASD for movement is standard -- check if KeyboardFallback intercepts 'w' and if so, ensure both can coexist (movement is continuous hold, spell cast is single press).

4. In `update(dt)`:
- After updating spell caster pools and before entity manager update, update enemy pool: `this.slimePool.update(dt, this.player);`
- After entity manager update and boundary behavior, run collision detection: `this.collisionSystem.update(dt);`
- Update boundary behavior: enemies should NOT wrap around. Add specific handling: entities with type starting with 'enemy-' should be clamped to canvas bounds (or allowed to enter from edges for spawning but not exit). Keep them on screen once they're in-bounds.
- Spawn a test wave: For initial testing, spawn 5 slimes at random screen edges in init() after pool creation. Use `ENEMY_CONFIG.slime` values.

5. In `render(interpolation)`: Pass player reference to RenderPipeline for HUD rendering.

6. In `resize()`: Update player canvas size: `if (this.player) this.player.setCanvasSize(this.width, this.height);`

7. In `destroy()`: Clean up WASD listeners, null out player/slimePool/collisionSystem.

**Modify `src/game/systems/RenderPipeline.js`:**
Add HUD layer for HP bar. Changes:

1. Add a `renderHUD(ctx, player, canvasWidth, canvasHeight)` method:
- If no player or player not active, return.
- Draw HP bar in top-left: x=20, y=20, width=200, height=12.
- Background: dark semi-transparent bar `rgba(0, 0, 0, 0.6)` with 1px border `rgba(126, 184, 218, 0.3)`.
- Foreground: HP percentage fill. Color: green (#4caf50) when > 50%, yellow (#ff9800) when > 25%, red (#f44336) when <= 25%.
- Label: "HP" text to the left of the bar in small font, using the teal color `rgba(126, 184, 218, 0.8)`, Cinzel or monospace font.
- If player just took damage (hitFlashTimer > 0), pulse the bar border brighter.

2. Update `render()` method signature to accept player: `render(ctx, entityManager, inputSystem, interpolation, gestureUI, player)`
- Add Layer 5 after UI overlays: `this.renderHUD(ctx, player, ctx.canvas.width, ctx.canvas.height);`

3. Update the GameEngine render call to pass player to RenderPipeline.
  </action>
  <verify>
Check CollisionSystem exists: `ls src/game/systems/CollisionSystem.js`
Check GameEngine imports: `grep "CollisionSystem\|Player\|EnemyPool" src/game/engine/GameEngine.js`
Check RenderPipeline has HUD: `grep "renderHUD\|hpBar\|HP" src/game/systems/RenderPipeline.js`
Check collision detection function: `grep "checkCircleCollision\|circleCollision\|distanceSquared" src/game/systems/CollisionSystem.js`
Run dev server: `npm run dev` -- verify no import errors in browser console.
  </verify>
  <done>
CollisionSystem: Circle-circle collision using squared distance, detection-then-response pattern, handles projectile-enemy and enemy-player collision types. Projectiles deal getDamage() to enemies, enemies deal contactDamage to player.
GameEngine: Player spawns at center, moves with WASD, SlimePool with 20 pre-allocated slimes, CollisionSystem wired into update loop (after entity update, before render), test slimes spawn at edges. WASD coexists with Q/W/E keyboard spells.
RenderPipeline: HP bar HUD at top-left (200x12px) with green/yellow/red health colors and "HP" label. Renders as final layer above UI overlays.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Run `npm run dev` -- game loads without console errors
2. Player circle visible at center of screen, responds to WASD movement
3. Slime enemies visible, moving toward player with smooth chase behavior
4. Casting spells (draw circle or press Q) fires projectiles that destroy enemies on contact
5. Enemies flash white when hit, health bars decrease, die when HP reaches 0
6. Player HP bar visible at top-left corner of HUD
7. Walking into an enemy causes player HP to decrease (contact damage), with visible i-frame flicker
8. Q/W/E keyboard spell shortcuts still work alongside WASD movement
</verification>

<success_criteria>
- Player entity exists, moves with WASD at 250 px/sec, stays within canvas bounds
- Slime enemies spawn at screen edges and chase player at 100 px/sec
- Projectile-enemy collision works: enemies take damage, flash white for 150ms, display health bar
- Enemy-player collision works: player takes 10 contact damage, 1000ms i-frames with visual flicker
- HP bar on HUD shows player health with green/yellow/red color stages
- All existing spell casting (gesture + keyboard) continues to work unchanged
- No frame rate degradation (maintain 60 FPS) with player + 5 slimes + projectiles active
</success_criteria>

<output>
After completion, create `.planning/phases/04-combat-system/04-01-SUMMARY.md`
</output>
